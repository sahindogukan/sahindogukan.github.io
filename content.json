{"pages":[],"posts":[{"title":"C Stili Dizilerden std::array'e...","text":"Programlama dillerinde diziler uygulanırken syntax olarak genelde C stili dizilerden ilham aldılar. Özellik olarak C stili dizilerin üzerine ihtiyaca göre üye fonksiyonlar da eklendi. C++11 ile gelen std::array ile C stili dizilerden çok daha fazla kullanışlılığa ve okunabilirliğe sahip kod yazılırken performans anlamında ise neredeyse aynı seviyede sayılır. std::array C stili diziler gibi statik boyutludur ve bellekte derleme zamanında yer ayrılır. std::array ‘ e genel bakışstd::array arka planda C stili dizinin ve ilgili üye fonksiyonlarının bulunduğu array sınıf şablonu yapısındadır. 123456789templateclass array{public: T _data[N]; T& operator[](size_t); const T& operator[](size_t) const; // other member functions and typedefs}; std::array kullanmak için #include ile array kütüphanesi projeye eklenir. std::array uzunluğu derleme zamanında hesaplandığından ve o bilgi oluşturulan nesne içerisindeki bir değişkende saklandığından sonradan o std::array nesnesinin uzunluğunu öğrenmek kolay ve hızlıdır. std::array oluşturmakstd::array iki bileşenden oluşur: İlki array içinde saklanacak elemanların tipi ve ikincisi array nesnesinin ne kadar eleman tutacağı (yani uzunluğu). 12345//a1 dizisi 10 int tipinde eleman tutarstd::array a1;//Tanımlama sırasında değerler atanabilirstd::array a2 = {-1, 1, 3, 2, 0}; Ayrıca mevcut diziler yeni dizilere atama yoluyla kopyalanabilir. 12345//atama yoluyla yeni kopya dizi oluşturmaauto a3 = a2;//constructor ile de kopya dizi oluşturulabilirauto a4(a2); Aynı uzunluktaki başka bir dolu diziye = operatörü ile atama yapılabilir ama uzunluklar aynı olmadığında hata alınacaktır. 123456//a3 dizisi değerlerini a2 dizisine atamaa2 = a3;// '=' operatörü iki dizi aynı boyutta ise kullanılabilir.//Hata://a1 = a2; // vs ! geçersiz std::array içindeki verilere erişmekstd::array içindeki verilere dizilerden alıştığımız şekilde [] operatörü ile de erişebiliriz ama sınır kontrolü yapmadığından dizi boyutundan farklı değerlerde hata alınacaktır. 12//beklenilen şekilde değer atamaları gerçekleşira3[0] = -2; Sınır kontrolü için at() üye fonksiyonu kullanılabilir. 1234std::cout <","link":"/2019/11/17/C-Stili-Dizilerden-std-array-e/"},{"title":"#2 Spread Operator Kullanımı","text":"Programlarımızı yazarken çoğu zaman çoklu parametrelerle uğraşmışızdır. Parametre sayılarımız kimi zaman bizim belirlediğimiz sayıda olurken kimi zaman da bir değişkene veya özel bir duruma bağlı olarak değişken sayıda ve belirsiz olabilir. Bu gibi durumlarda kullandığımız yazılım dilinin desteklediği standartlara göre en optimum ve kısa yolla istediğimiz kodu yazmaya çalışırız. Ecmascript 6 ile sunulan “Spread Operator” ve “Rest Parameters” kavramları, tam da bu durumlarda bizlere çok büyük kolaylıklar sağlıyor. Örnek üzerinden anlatacak olursak; bir sınıftaki 5 öğrencinin notlarını tutan dizideki elemanları, not ortalamasını hesaplayan ortalamaHesapla adlı fonksiyona parametre olarak gönderelim ve sonucumuzu alalım. Öncelikle spread operator kavramını daha iyi anlamak açısından bunu daha önce ES5 standartları ile nasıl yapıyorduk ona bakalım: 12345678function notHesapla(ogr1,ogr2,ogr3,ogr4,ogr5,ogr6) { return (ogr1+ogr2+ogr3+ogr4+ogr5)/arguments.length;}let notlar = [50,50,50,60,60];// Fonksiyona parametre olarak bir dizi göndermemiz için apply() metodunu kullanmamız gerekir.let ortalama = notHesapla.apply(null,notlar); console.log(ortalama); Spread operator kullanımı değişkenin başına “…” şeklindedir. Şimdi aynı örneği bir de spread operator kullanarak yapalım. 12345678function notHesapla(ogr1,ogr2,ogr3,ogr4,ogr5,ogr6) { return (ogr1+ogr2+ogr3+ogr4+ogr5)/arguments.length;}let notlar = [50,50,50,60,60];// Göndermek istediğimiz dizinin başına \"...\" koyarak bu işlemi daha da basitleştirdik.let ortalama = notHesapla(...notlar); console.log(ortalama); Spread operatorlerin kullanım alanı tabi ki de bu kadar kısıtlı değil. Şimdi daha farklı hangi alanlarlada kullanabiliriz onları inceleyelim: Bir dizinin elemanlarına tek seferde ulaşımı1234567let arr1 = [1,10,100,1000,10000];let arr2 = [\"Güner\",\"Bilgili\",\"Şahin\"];console.log(...arr1);console.log(...arr2);// Console: 1 10 100 1000 10000// Güner Bilgili ŞahinBu bir karakter dizisi de olabilir; 123let arr3 = \"Güner\";console.log(...arr3);// Console: G ü n e r Dizileri birleştirme12345let kisiler1 = ['Mehmet', 'Sahin'];let kisiler2 = ['Suzan','Sahin'];let arr3 = [...kisiler1, ...kisiler2];console.log(arr3);//Console: [ 'Mehmet', 'Sahin', 'Suzan', 'Sahin' ]Aynı işlem dizilerdeki push() metodu aracılığı ile dizilerin üzerine eklenerek de yapılabilir.12345let kisiler1 = ['Mehmet', 'Sahin'];let kisiler2 = ['Suzan','Sahin'];kisiler1.push(...kisiler2)console.log(kisiler1);//Console: [ 'Mehmet', 'Sahin', 'Suzan', 'Sahin' ] Objelerin kopyalanması ve birleştirilmesi1234let obj1 = {name: \"Kubra\", surname: \"Sahin\", age: 25}let obj2 = {...obj1}console.log(obj2)// Console: { name: 'Kubra', surname: 'Sahin', age: 25 }1234let obj1 = {name: \"Kubra\", surname: \"Sahin\", age: 25}let obj2 = {name_:\"Dogukan\", surname_:\"Sahin\", age_:23, ...obj1}console.log(obj2)// Console: { name_: 'Dogukan', surname_: 'Sahin', age_: 23, name: 'Kubra', surname: 'Sahin', age: 25 } Yukarıdaki örnekte dikkat ederseniz birleştime işlemi yaparken farklı objelerin aslında aynı olan özellik isimlerine ufak bir değişiklik yaparak aynı olmamasını sağladık. Bunun sebebi, eğer iki objede aynı özellikler çakışırsa, son nesnenin özelliği diğerini ezer ve o geçerli olur. 1234let obj1 = {name: \"Kubra\", surname: \"Sahin\", age: 25}let obj2 = {...obj1, name:\"Dogukan\", surname:\"Sahin\", age_:23}console.log(obj2)// Console: { name: 'Dogukan', surname: 'Sahin', age: 25, age_: 23 } Matematik fonksiyonlarınında kullanımı123let sayilar = [8, 233, 43, -565, 92, -12, 96, 22, 75, 700, 254, -1633];let min = Math.min(...sayilar);console.log(min); Daha fazlası için: - Spread syntax - JavaScript | MDN - Mozilla","link":"/2020/01/30/2-Spread-Operator-Kullanimi/"},{"title":"#1 Arrow Function Kavramı","text":"Ecmascript6 ile Javascript dünyasına giren en önemli özelliklerden biri de, ilhamını CoffeScript’in arrowfonksiyonlarından alan tabiri caizse ok fonksiyonu da diyebileceğimiz arrow functionlardır. Arrow functionlarbizlere, klasik Javascripteki fonksiyon tanımı yaparken kullandığımız “function” komutunun yerine “=>” ibaresi ile daha yalın ve okunabilir fonksiyon tanımları yapmamıza olanak sağlar. Basitçe her iki yapıyı inceleyecek olursak; 123456789 // Regular Function function isimYazdir(isim) {console.log(\"İsim:\" + isim)} // Arrow Functionconst isimYazdir = (isim) => {console.log(\"İsim:\" + isim)}; // Burada eğer parametre sayımız bir ve fonksiyonumuzun gövdesi tek satırdan oluşursa şu şekilde de yazabilirizconst isimYazdir = isim => console.log(\"İsim:\" + isim); Burada arrow fonksiyonumuzu bir değişkene atadık. Normalde arrow fonksiyonlar anonim yani isimsiz fonksiyonlardır. Gerektiği zaman direkt kullanıldığı gibi (IIFE), bir değişkene atanarak da kullanabiliriz. 12// IIFE fonksiyon yapısı ile arrow fonksiyonunun direkt kullanımı (isim => console.log(isim))(\"Merhaba Arrow Function\"); Verilen iki parametreyi birleştirip geri döndüren bir fonksiyonu arrow fonksiyon kullanarak yazalım; 123456789const isimGetir = (isim,soyisim) => { return isim + \" \" + soyisim}// Kullanım: let gelenİsim = isimGetir(\"Güner\",\"Bilgili\");console.log(gelenİsim)//Console: Güner Bilgili Arrow fonksiyonların regular fonksiyonlardan ayıran en önemli özelliklerden bir tanesi de kendi “this” değerine sahip olmamalarıdır. Yani daha açık bir ifade ile bir fonksiyondan nesne üreteceksek, ardından o nesneye ait bir metot tanımlamıssak ve bunu bir arrow fonksiyon ile yazdıysak, içinde kullanılan this anahtar sözcüğü o arrow fonksiyonunu kapsayan ana yürütücü fonksiyonun this değerini kullanır. 12345678function fonk1() { this.isim = isim; const isimYaz = () => {console.log(this.isim)} // buradaki this, ana fonksiyondaki değişkeni işaret eder. isimYaz();}// Kullanım:const isim = new fonk1(\"Güner Bilgili\")//Console: Güner Bilgili Peki bu durum normalde regular fonksiyonlarda nasıl diye sorarsak, her bir fonksiyon oluşturulduğu an kendi this değerini tanımlar. Bu durumda aynı örnek üzerinden gidecek olursak “isimYaz” adlı fonksiyon arrow fonksiyon olmasaydı kendi this değerini tanımlayacak ve üstteki değişkene ulaşamayarak undefined döndürecekti. 12345678910function fonk1(isim) { this.isim = isim; function isimYaz() { console.log(this.isim); // Buradaki isimYaz fonksiyonu kendi this değerini üreteceği için fonk1'e ait isim değişkenini göremeyecektir. } isimYaz();}// Kullanım:const isim = new fonk1(\"Güner Bilgili\")//Console: undefined Daha fazlası için: - Arrow functions - JavaScript | MDN","link":"/2020/01/30/1-Arrow-Function-Kavrami-1/"},{"title":"#3 Rest Parametre Kullanımı","text":"Bir önceki yazımızda Spread Operator kavramını incelemiş ve spread operatörü ile bir argüman topluluğunu “…” kullanımı ile tek seferde fonksiyonlarına aktarabiliyor veya farklı alanlarda bu değişkenleri kullanabiliyorduk. Rest parametrelerinin kullanımı spread operatoru ile aynıdır fakat bu kafanızı karıştırmasın, işlevi tam tersi diyebiliriz. Rest parametreleri bizden aldığı argümanları bir dizi gibi toplayarak üzerinde değişik işlemler yapmamıza olanak sağlar. Rest parametreleri sayesinde fonksiyonlara sınırsız eleman gönderebiliriz. Daha iyi anlamak ve önemini kavramak açısından bir örnekle devam edelim. Gönderdiğimiz değişkenlerin toplamını geri döndüren bir fonksiyonu öncelikle ES6 öncesi standartlarla yazalım:1234567function topla(sayi1,sayi2,sayi3){ return sayi1+sayi2+sayi3;}let toplam = topla(2,3,4);console.log(toplam);//Console: 9// topla(2,3,4,5) gönderseydik?Burada değişken sayıda parametre yolladığımızda ilk 3 değeri parametre olarak alacak, ve ekstra gönderdiğimiz diğer değerleri işleme alamayacaktır. Bunun için gönderdiğimiz parametre sayısı kadar fonksiyonumuzda da o parametreleri karşılamamız gerekir. İşte tam da bu durumda ES6’ın bize sunduğu rest parametresi işimizi çok kolay ve pratik hale getiriyor. Kaç adet parametre yollarsak yollayalım rest parametresi ile karşılayıp, üzerinde gerekli işlemleri yapabiliriz. 12345678910111213function topla(...rest){ // ...rest parametresi ile istediğimiz kadar parametre alabiliriz. let toplam = 0; for(let i of rest){ toplam+=i; } return toplam;}console.log(topla(1,2));console.log(topla(1,2,3));console.log(topla(1,2,3,4,5));// Console: 3// 6// 15NOT: 1) Bir fonksiyon için sadece bir adet rest parametresi kullanılabilir. 2) Rest parametresi başka parametrelerle beraber kullanılacaksa fonksiyonun son parametresi olmalıdır. 1234567const kareAl = (num1,num2, ...list) => // İlk iki değer (16 ve 21) num1 ve num2'ye atanır. Geri kalan bütün değerler ise list rest parametresine.{ list.push(num1,num2); list.forEach(sayi => {console.log(sayi*sayi)})};kareAl(16,21,3,9,11,22,14);//Console: 9 81 121 484 196 256 441 Şimdi ise spread operatoru ve rest parametresi kullanarak dogum yıllarının bulunduğu bir obje dizisini, oluşturduğumuz yasHesapla adlı fonksiyona gönderelim ve sonuçları konsolda yazdıralım. 12345678910111213141516171819const yasHesapla = (...list) =>{ list.forEach(kisi => { console.log(kisi.name, 2020 - kisi.year)})};const list1 = [{name:\"Ali\", year:1996}, {name:\"Ebrar\",year:1975},{name:\"Efe\", year:1991}];const list2 = [{name:\"Bilal\", year:1998}, {name:\"Gülcin\",year:1990},{name:\"Elif\", year:2001},{name:\"Burak\",year:2005},{name:\"Gozde\", year:1987}];yasHesapla(...list1); // 3 elamanlı bir dizi yolladık.yasHesapla(...list2); // Aynı fonksiyona bu sefer 5 elemanlı bir fonksiyon yolladık. // Console: Ali 24// Ebrar 45// Efe 29// Bilal 22// Gülcin 30// Elif 19// Burak 15// Gozde 33 Daha fazlası için: - Rest parameters - JavaScript | MDN","link":"/2020/01/30/3-Rest-Parametre-Kullanimi/"},{"title":"#4 Destructuring Kavramı","text":"Ecmascript6 ile karşımıza çıkan yeni özelliklerden bir tanesi de Destructuring kavramıdır. Destructuring dizilerden, nesnelerden veya objelerden elde edilen değerlerin parçalanılarak farklı değişkenlere kolayca aktarılmasını sağlar. 3 elamanlı bir dizideki değerleri destructuring kavramı ile farklı değişkenlere aktarımı şu şekildedir: 123456789[x,y,z] = [10,100,1000];console.log(x);console.log(y);console.log(z);//Console: 10// 100// 1000 Rest parametresi içeren bir parçalama işlemi: 1234567[a, b, ...rest] = [12, 45, 47, 78, 112,155,178];console.log(a); console.log(b); console.log(rest);//Console: 12// 45// [ 47, 78, 112, 155, 178 ] Destructuring kavramı ile tanışmadan önce dizilerdeki değişkenlerin nasıl farklı değişkenlere dağıtıldığını bir örnek üzerinden inceleyelim: 123456let futbolcuBilgisi = [\"Merih\",\"Demiral\",21];let name = futbolcuBilgisi[0];let surname = futbolcuBilgisi[1];let age = futbolcuBilgisi[2];console.log(name,surname,age)//Console: Merih Demiral 21 Şimdi de aynı işlemi destructuring özelliği uygulayarak yeniden yazalım:1234let futbolcuBilgisi = [\"Merih\",\"Demiral\",21];let [name,surname,age] = futbolcuBilgisi;console.log(name,surname,age)//Console: Merih Demiral 21 Diziler üzerinde olduğu gibi aynı kavram objeler üzerinde de geçerlidir: 1234let futbolcuBilgisi = {name:\"Çağlar\", surname:\"Söyüncü\", age:23};let {name,surname,age} = futbolcuBilgisi;console.log(name,surname,age)//Console: Çağlar Söyüncü 23 Destructuring işlemi yapılırken atanacak değişkenlere varsayılan değer atanabilir. Eğer o değişkene değer atanmadığı zaman default değer geçerli olur. Eğer bir değer atanmışsa ise atanan değer default değeri ezer: 1234let futbolcuBilgisi = {name:\"Cengiz\", surname:\"Ünder\"};let {name,surname,age=\"Belirtilmemiş\"} = futbolcuBilgisi;console.log(name,surname,age)//Console: Cengiz Ünder BelirtilmemişDeğişken atamaları yaparken eğer bir değeri atlamak istiyorsak “,” ibaresini kullanarak o değeri boş sayabiliriz:12345// Başta ve sonda 2 kere \",\" kullarak o değerleri atlamış ve ortadaki değeri almış olduk.let futbolcuİsimleri = [\"Yusuf\",\"Cengiz\",\"Merih\",\"Cenk\",\"Ozan\"];let [,,name,,] = futbolcuİsimleri;console.log(name)//Console: MerihDaha fazlası için: - Destructuring assignment - JavaScript | MDN","link":"/2020/01/30/4-Destructuring-Kavrami/"},{"title":"#5 ES6 Map Kullanımı","text":"Ecmascript6, Map kavramı ile bizlere anahtar/değer çiftelerini tutmamızı sağlar. Herhangi bir ilkel değişken veya obje anahtar veya değer olarak atanabilir. Kullanımı “new Map([iterable])” şeklindedir. Konuya daha hakim olmak adına bu bilgileri örneklendirelim. Bir map objesi oluşturalım ve üzerinde işlemler yapmak için bunu bir değişkene atayalım: 1const ilPlakaları = new Map(); 1) Oluşturduğumuz objenin içerisine ekleme yapmak istediğimiz zaman set() metodunu kullanırız: 12345678910ilPlakaları.set(34,\"İstanbul\");ilPlakaları.set(23,\"Elazığ\");ilPlakaları.set(35,\"İzmir\");ilPlakaları.set(66,\"Yozgat\")console.log(ilPlakaları)// Console: Map {// 34 => 'İstanbul',// 23 => 'Elazığ',// 35 => 'İzmir',// 66 => 'Yozgat' }2) Elamanlar üzerinden seçme işlemi için get() metodunu kullanırız. Seçme işlemi için key değerlerini kulllanıyoruz.1234const il1 = ilPlakaları.get(23);const il2 = ilPlakaları.get(35);console.log(il1,il2)// Console: Elazığ İzmir3) Elaman sayısı için size özelliğini kullanırız:123const elemanSayisi = ilPlakaları.size;console.log(elemanSayisi)// Console: 44) ilPlakaları içerisinde herhangi bir değerin olup olmadığını sorgulamak için has() metoduna key değerini atarak sorgulayabiliriz. Bizlere boolean tipinde bir değer döndürecektir:1234console.log(ilPlakaları.has(34));console.log(ilPlakaları.has(58))// Console: true// false5) Herhangi bir elemanı silmek için delete() metoduna bir anahtar değerini göndeririz:123ilPlakaları.delete(35)// Eğer bütün elemanları silmek istiyorsak clear() metodunu kullanırız.// ilPlakaları.clear() Sadece anahtar ve değer değişkenleri görmek istersek: Anahtar değerleri için;12345678for(let key of ilPlakaları.keys()){ console.log(\"Key:\" + key)}//Console: Key:34// Key:23// Key:35// Key:66Key değerleri için;12345678for(let key of ilPlakaları.keys()){ console.log(\"Key:\" + key)}//Console: Key:34// Key:23// Key:35// Key:66Value değerleri için;12345678for(let value of ilPlakaları.values()){ console.log(\"Value:\" + value)}//Console: Value:İstanbul// Value:Elazığ// Value:İzmir// Value:Yozgat Daha fazlası için: - Map - JavaScript | MDN","link":"/2020/01/30/5-ES6-Map-Nesnesi/"},{"title":"#6 ES6 Set Kullanımı","text":"Bir önceki yazımızda ES6 ile gelen Map objesini incelemiştik. Şimdi ise bir başka collection türü olan Set kavramını inceleyelim. Map objeleri ile key/value değerlerini tutuyorduk, set objeleri ise ilkel veya referans tipli olsun tekil (unique) değerler saklamamızı sağlayan nesnedir. setObj adında bir set objesi oluşturalım ve üzerinde ne gibi işlemler yapabiliriz inceleyelim: 123456789101112const setObj = new Set();setObj.add(2);setObj.add(\"dört\");setObj.add(66);setObj.add([2,4,6]);setObj.add({name:\"Güner\", surname:\"Bilgili\"});setObj.add({name:\"Güner\", surname:\"Bilgili\"}); setObj.add(66);console.log(setObj);//Console: Set { 2, 'dört', 66, [ 2, 4, 6 ], { name: 'Güner', surname: 'Bilgili' },{ name: 'Güner', surname: 'Bilgili' } } ////İki kere 66 eklemiştik, fakat çıktıda 1 kere yazdı?Çıktımızda dikkat ettiysek 66 değerini iki kere eklememize karşın objemize bir kere eklendi. Set nesnesi başta da belirttiğimiz üzere tekil değerler tutmamızı sağlar ve aynı değeri sadece bir kere tutar. Peki madem öyle aynı değerlere sahip “{name:”Güner”, surname:”Bilgili”}” objesini iki kere nasıl ekleyebildik diye sorabilirsiniz. Objeler bellekte ilkel değişkenler gibi değerleri ile değil referans adresleri ile tutulurlar. Yani biz içerisindeki değerleri aynı olsa da bir başka obje tanımladığımız zaman referansı diğerinden farklı olacağından iki farklı nesne gibi set objemize eklenebilecektir. Map objesinde olduğu gibi bir değişkeni barındırıp barındırmadığını sorgulamak istersek yine has() metodunu kullanırız: 1234console.log(setObj.has(\"dört\"));//Console: trueconsole.log(setObj.has(75));//Console: false Eleman sayısı için yine size özelliğinden yararlanılır:123const elemanSayisi = setObj.size;console.log(elemanSayisi)// Console: 6 Eleman silmek istediğimiz zaman yine delete() metodunu kullanırız:1setObj.delete(\"dört\")Oluşturduğumuz set objesini bir diziye çevirip, dizi metotlarından yararlanmak isteyebiliriz. Bunun için Array sınıfının from() metoduna ilgili set objemizi vermemiz yeterli olacaktır: 123const array = Array.from(setObj);console.log(array);//Console: [ 2,'dört',66,[ 2, 4, 6 ],{ name: 'Güner', surname: 'Bilgili' },{ name: 'Güner', surname: 'Bilgili'] Daha fazlası için: - Set - JavaScript | MDN","link":"/2020/01/31/6-ES6-Set-Kullanimi/"},{"title":"#7 ES6 Class Kavramı","text":"Nesneye dayalı programlama dillerinden de aşina olduğumuz class kavramı artık Ecmascript6 ile birlikte javacript tarafında daha kolay ve okunaklı bir yapı sunuyor. ES6 öncesi standartlarda bir nesne üretmek istediğimiz zaman constructor fonksiyonları oluşturuyorduk. Bu oluşturduğumuz objelerden kalıtım yolu ile yeni objeler oluşturmak istediğimiz zaman ise prototype metotlarından yararlanıyorduk. ES6 class kavramı bizlere OOP presiplerini daha verimli ve kolay bir şekilde kullanma olanağı sunuyor. ES6 class kavramına geçmeden, önceki standartlarda yeni bir obje üretmek için neler yapıyoduk inceleyelim: 1234567891011// Yapıcı metot fonksiyonumuzu tanımlayarak Student ismini verdiğimiz değişkene atıyoruz.// Değişkene atamadan fonksiyona isim vererek de tanımlayabiliriz. function Student(name,surname,scholl)... gibi.var Student = function (name,surname,scholl) { this.name = name; this.surname = surname; this.scholl = scholl;};var ogrenci1 = new Student(\"Güner\",\"Bilgili\",\"YTU\");console.log(ogrenci1)//Console: Student { name: 'Güner', surname: 'Bilgili', scholl: 'YTU' }Burada yapıcı metodumuzun içerisine istediğimiz amaçla bir metot oluşturabiliriz. Fakat ürettiğimiz her bir örnekte bu fonksiyon da oluşturulacağından bellek kullanımı konusunda pek mantıklı bir seçim olmayacaktır. Bunun yerine oluşturduğumuz Student objesinin prototype özelliğine ulaşarak, oluşturacağımız metodu burada tanımlayabiliriz. Bunun amacı Student objesinden üretilen her bir örneğin, sadece gerekli olduğu zamanlarda bu metoda erişerek bellekte gereksiz metot tanımının önüne geçmektir.1234567Student.prototype.bilgileriYazdir = function () { console.log(\"Adı: \" + this.name + \" Soyadı: \" + this.surname + \" Okulu: \" + this.scholl);};const ogrenci1 = new Student(\"Güner\",\"Bilgili\",\"YTU\");ogrenci1.bilgileriYazdir();//Console: Adı: Güner Soyadı: Bilgili Okulu: YTU Şimdi ES6’ın bize sunduğu Class kavramını inceleyelim:Sınıf tanımlamaları “class” anahtar kelimesi ile tanımlanır. Class bir isimle tanımlanacağı gibi isimsiz şekilde tanımlanıp bir değişkene de atanabilir.12345678const Personel = class { ...}class Personel { ...}Sınıfımızın içerisine yazdığımız constructor, ilgili sınıf çağrıldığı an çalışır ve gönderdiğimiz gerekli parametrelerin değişkenlere aktarılmasını sağlar.123456const Personel = class { constructor(name,personID){ this.name = name; this.personID = personID; }};Metot tanımlamalarımızı ilgili sınıf içerisinde tanımlarız. 123456789const Personel = class { constructor(name,personID){ this.name = name; this.personID = personID; } personelAktifEt(){ console.log(\"Personel Aktif Edildi.\"); }};Şimdi de bir önceki örneğimizi ES6 Class kavramı ile yeniden yazalım: 123456789101112131415const Student = class { constructor(name,surname,scholl){ this.name = name; this.surname = surname; this.scholl = scholl; } bilgileriYazdir(){ console.log(\"Adı: \" + this.name + \" Soyadı: \" + this.surname + \" Okulu: \" + this.scholl); }}const ogr2 = new Student(\"Güner\",\"Bilgili\",\"YTU\");console.log(ogr2);ogr2.bilgileriYazdir();//Console: Adı: Güner Soyadı: Bilgili Okulu: YTU","link":"/2020/02/01/7-ES6-Class-Kavrami/"},{"title":"#8 ES6 Static Metot ve Kalıtım (Subclass) Kavramları","text":"Bir önceki yazımızda ES6 ile beraber gelen Class kavramından bahsetmiş ve sınıflardan ürettiğimiz nesneler ile içerisine yazdığımız yardımcı metotlara ulaşabildiğimizi görmüştük. Bu yazımızda static metotlara ve kalıtım kavramına değineceğiz. 1) Static MetodlarStatic yardımcı metotlar; içerisindeki sınıf değişkenlerinden bağımsız, ilgili sınıftan bir nesne üretmeden, sınıf ismi ile ulaşabildiğimiz metotlardır. Static yardımcı metotlara ilgili sınıf parametrelerinden bağımsız parametreler gönderip istediğimiz sonucu geri döndürebiliriz. Metodlara sınıf üzerinden erişimi bir örnek üzerinden anlatalım: Oluşturduğumuz PuanTablosu isimli sınıf, içerisindeki puanHesapla() adlı yardımcı static metot ile gönderdiğimiz parametreler neticesinde ilgili takımın toplam puanınını göndersin. Gönderdiğimiz “G” (Galibiyet) parametresi +3, “B” (Beraberlik) parametresi ise toplam puana +1 eklesin. “M” (Mağlubiyet) ise puana hiç bir etki yapmasın.Oluşturduğumuz her bir obje bir maç değerine karşılık gelmektedir. 1234567891011121314151617181920212223242526class PuanTablosu { constructor(sonuc) { if (sonuc === \"G\") { this.sonuc = \"G\"; }else if(sonuc === \"B\"){ this.sonuc = \"B\"; }else if(sonuc === \"M\"){ this.sonuc = \"M\"; } } static puanHesapla(...mac) { let puan = 0; for (let i of mac) { if(i.sonuc === \"G\"){ puan += 3; }else if (i.sonuc === \"B\") { puan += 1; } } console.log(\"Toplam puan: \"+puan); }} Kullanım: 12345678const mac1 = new PuanTablosu(\"G\"); //+3const mac2 = new PuanTablosu(\"M\"); // 0const mac3 = new PuanTablosu(\"B\"); //+1const mac4 = new PuanTablosu(\"B\"); //+1const mac5 = new PuanTablosu(\"G\"); //+3// Static yardımcı metodumuza class üzerinden erişim sağladık.PuanTablosu.puanHesapla(mac1,mac2,mac3,mac4,mac5);//Console: Toplam puan: 8 1) ES6 ile KalıtımDiğer programlama dillerinde olduğu gibi javascript tarafında da oluşturduğumuz sınıfların özelliklerini kalıtım yolu ile başka bir sınıfa aktarabiliyorduk. Fakat bu biraz aşina olduğumuz yapılardan biraz farklı oluyordu. İsterseniz ES6 standartları ile kalıtım örneğine geçmeden önce bir örnek ile daha önceden nasıl kalıtım alıyorduk inceleyelim. Akademisyen ve Personel adında iki adet sınıfımız olsun ve Akademisyen sınıfı Personel sınıfının özelliklerinden kalıtım yolu ile yararlansın. 1234567891011121314function Personel(ad,soyad) { this.ad = ad; this.soyad=soyad;}Personel.prototype.bilgiYazdir = function () { console.log(\"Unvanı: \" + this.unvan + \" Adı: \" + this.ad + \" Soyadı: \" + this.soyad)};function Akademisyen(ad,soyad,unvan) { //call metodu ile Personel sınıfının constructoruna ulasıp, ilgili objemizi ve özeliiklerimi gönderiyoruz. Personel.call(this,ad,soyad); this.unvan = unvan;}Şimdi ise kalıtımı sağlayacak olan atamayı yapalım. Object.create() metoduna Akademisyen sınıfımızın prototype kısmını vererek bunu Akademisyen sınıfımızın prototype ına ekle veya at demiş oluyoruz. Yani Personel sınıfımızdaki bütün özellikler artık Akademisyen sınıfı tarafından da kullanılmış oluyor.1Akademisyen.prototype = Object.create(Personel.prototype);Kullanım: 123var akademisyen = new Akademisyen(\"Kubra\", \"Şahin\", \"Doc.Dr\");akademisyen.bilgiYazdir();//Console: Unvanı: Doc.Dr Adı: Kubra Soyadı: Şahin ES6 ile kalıtım kavramını inceleyelim;ES6 standartları ile sınıflar arası kalıtım “extends” anahtar kelimesi ile sağlanır.123class altSınıf extends ustSınıf{ ...}Ust sınıfa erişim için ise “super()” metodundan yararlanılır.1234567class altSınıf extends ustSınıf{ constructor(param1,param2,param3){ super(param1,param2); ... } ...} Şimdi aynı örneğimizi ES6 sonrası kalıtım kavramı ile yeniden yazalım 12345678910111213141516171819202122class Personel { constructor(ad, soyad, unvan) { this.ad = ad; this.soyad = soyad; } bilgiYazdir() { console.log(\"Unvanı: \" + this.unvan + \" Adı: \" + this.ad + \" Soyadı: \" + this.soyad) }}class Akademisyen extends Personel{ constructor(ad,soyad,unvan){ super(ad,soyad); this.unvan = unvan; }}var akademisyen = new Akademisyen(\"Kubra\", \"Şahin\", \"Doc.Dr\");akademisyen.bilgiYazdir();//Console: Unvanı: Doc.Dr Adı: Kubra Soyadı: Şahin","link":"/2020/02/02/8-ES6-Static-Metot-ve-Subclass-Kavramlari/"},{"title":"React Native: Event ve State Kavramları","text":"Bu yazımızda React Native tarafında “Event” kavramı yani olay yönetimi nasıl gerçekleştiriliyor, ardından da “State” kavramı ve kullanımına değineceğiz.Bildiğimiz üzere “Event” HTML tarafında elementlerde gerçekleşen durumlardır. Bu olaylar kullanıcı yani bizler tarafından tetikleneceği gibi tarayıcı tarafından da tetiklenebilir. Butona tıklanılması durumda gerçekleşen onclick, elementlerde değişiklik olduğunda gerçekleşen onchange, klavyeden herhangi bir tuşa basılması durumunda gerçekleşen onkeydown bu olaylara başlıca örnek olarak verilebilir. React Native: EventReact Native tarafında event kullanımı HTML’deki kullanıma oldukça benzerdir. RN tarafında fonksiyon isimleri event’e direkt olarak atılır ve event isimlendirmeleri “camelCase” biçimde adlandırılır. Örnek olarak App.js dosyamız içerisinde bir Button bileşeni tanımlayalım ve bu butona tıklanıldığında “onPress” event’ini tetikleyerek bize bir alert mesajı vermesini sağlayalım. React Native: State“State”, component’lerin içerisine yazdığımız, ve içerisindeki herhangi bir değer değiştiği zaman ilgili bulunduğu component’in tekrar render edilmesini sağlayan bir objedir. Yani ne demek istedik, bileşenimiz içerisinde belli bir anda değişebilecek veya değiştirmek istediğimiz değerleri state içerisine tanımlarız. Örnek vermek gerekirse; bir sayaç tasarladığımızı düşünelim. Sayacın değerini artırıp, azaltmak istediğimizde bu değer sürekli değişecektir ve bu değeri bir state objesi içerisinde tanımlamamız gerekecektir. Şimdi bu örneğimizi gerçekleştirerek state kavramını daha iyi anlayalım. 1) State tanımı ilgili component’in içerisinde state= {…} şeklinde tanımlanır.2) Bir state içerisindeki eleman değiştirmek istenildiği zaman this.setState({…}) çağrımı yapılır. Yapılacak olan değişim bu yapı içerisinde tanımlanır. Örneğimizde iki adet buton kullanarak yazdığımız “sayacAzalt” ve “sayacArttir” fonksiyonları ile state içerisine tanımladığımız sayi değişkenimizi this.setState() çağırımı yaparak artırıp, azaltacağız.","link":"/2020/02/05/React-Native-Event-ve-State-Kavramlari/"},{"title":"React-Native: Component Mantığı","text":"Türkçe karşılığı “bileşen” olan “component” React ailesinin en temel yapı taşıdır. Component özünde bir Javascript sınıfıdır ve bizim isteklerimiz ve girdilerimiz sonucunda bizlere UI’ın (Kullanıcı Arayüzü) nasıl ve ne şekilde gözükmesini açıklayan bir React ögesi döndürür. Componentlar bizlere asıl olarak bir işlevi veya ögeyi döndürmesi için yazılan bir kodun; farklı zamanda ve farklı yerlerde yeniden çağırılarak kod kalabalığından kaçınma olanağı, kolaylık ve işlevsellik sağlar. Component mantığını daha iyi anlamak açısından basitçe; işlevi “h1” etiketi içerisinde bir metin ifadesi döndüren fonksiyonel bir component ifadesi yazalım: 1const Merhaba = () => Merhaba React Native!;React Native projelerimizde yazdığımız birden fazla component birleşerek aslında yeni bir component oluşturur. Yani bu componentlar birleşerek aslında bizim RN uygulamamızı meydana getirir. Konuyu daha iyi kavramak açısından bir örnek üzerinden inceleyelim: Yukarıda yazdığımız fonksiyonel bileşende olduğu gibi sayfamızda; içerisinde Text componentı içeren bir ifadeyi döndüren component sınıfını oluşturalım ve bunun kullanımını görelim.“Text” aslında basic bir componenttir, yukarıda da belirttiğimiz üzere componentlar birleşerek yeni bir component oluşturur demiştik. Biz de burada yazdığımız component içerisinde başka bir componentı kullanacağız. Hello.js adında bir js dosyası oluşturduk ve içerisinde gerekli tanımlamaları yaparak “Hello” adını verdiğimiz sınıfımızı ata sınıf olan Component sınıfından extend ediyoruz. Şimdi de yazdığımız bu bileşeni App.js dosyamızda kullanalım. Component mantığını daha iyi oturtmak için bu bileşenimizi 3 kere çağıracağız. Yazdığımız bileşeni kullanabilmemiz için öncelikle App.js dosyamıza dahil etmemiz gerekiyor. İsterseniz components adında bir klasor oluşturup, yazdığınız componentları burada barındırabilirsiniz. Örnekte components klasorunun altında bulunduğu için import Hello from ‘./components/Hello.js’ şekliden yer alıyor.","link":"/2020/02/04/React-Native-Component-Mantigi/"},{"title":"React Native: Props Kavramı","text":"“Props” kavramı tahmin edileceği üzere “Property” (Özellik) kelimesinin kısaltılmasından meydana gelir. Bizler oluşturduğumuz bileşenlere bir özellik kazandırmak istediğimizde, bu propslar aracılığı ile inputlar girerek belirtilen değerlerin render edilebilmesini sağlayabiliriz. Bizler Component kavramı sayesinde kendi özel sınıflarımızı oluşturup bunları istedğimiz zaman çağırıp render edebiliyorduk. Şimdi de oluşturduğumuz bu bileşenlere özellik atamalarının nasıl olduğunu göreceğiz. Konuyu daha iyi anlamak açısından “Box” adında bir component sınıfı oluşturalım. Bu sınıfımızı her render ettiğimizde farklı property değerleri atayalım. Örneğimizde arkaplan rengi ve yazı değerini atayacağız. “Box” component sınıfı: App.js dosyamızda componentimizi çağırırken “bgColor” ve “text” adında iki adet property tanımı oluşturduk. Bu isimlere kendiniz farklı değerler verebilirsiniz. Gönderdiğimiz bu inputları this.props altında yakalabiliriz. Sırasıyla; “Box” bileşenimizin içerisinde arkaplan rengi ataması yapabilmek için, “View” bileşenine style özelliğine{backgroundColor:this.props.bgColor} değerini bu şekilde atadık. this.props altından gönderdiğimiz “bgColor” değerini yakaladığımıza dikkat edelim. Aynı şekilde “text” girdisini de {this.props.text} ile yakalayıp “Text” bileşeni içerisinde kullanıdık.","link":"/2020/02/04/React-Native-Props-Kavrami/"},{"title":"React Native: FlatList Kullanımı","text":"React Native uygulamalarımızda listeleme veya sıralama işlemi yapılacağı zaman akla ilk gelen ve kullanılan bileşen FlatList’tir. FlatList diğer bir tercih olan ListView’e göre daha hızlı ve performanslı çalışması nedediyle tercih sebebi olmuştur. Bu yazımızda FlatList kullanımını inceleyeceğiz. FlatList bileşenin en çok kullanılan özelliklerini bakacak olursak: data: Bileşenimiz içerisinde yer alacak ve sıralanacak veri bütünü. Bir array tipinde veri olmalıdır. renderItem: Verilerimizi atadıktan sonra bu verilerin kullanıcıya bir şekilde sunulması gerekiyor. Listedeki elamanların kullanıcı arayüzünde nasıl görünmesini istiyorsak, ilgili return edilecek bileşenleri yazdığımız yerdir. Fonksiyon tipinde yazılır. keyExtractor: Listedeki her bir elamana özel anahtar değer atamasının yapıldığı alandır. Bu değer “string” tipinde olmalıdır. onRefresh: Liste bileşenimizde herhangi bir yenileme işlemi yaptığımızda tetiklenecek olan fonksiyondur. Yenileme işlemi yapıldıktan sonra yapılacak olan işlemler bu fonksiyon içinde tanımlanır. extraData: Buraya atanacak bir state değişkeni değiştirildiği zaman liste kendisini otomatik olarak yeniler. Yani FlatList yeniden render edilmiş olur. Şimdi kisiListesi adında oluşturduğumuz ve içerisinde kişilerin id’sini, fotoğraf url’si ve adının bulunduğu objeleri bir FlatList yapısı oluşturarak listeleyelim.","link":"/2020/02/05/React-Native-FlatList-Kullanimi/"},{"title":"React-Native: Axios ile Web Servis Çağrımı","text":"Şimdiye kadar verilerimizi oluşturduğumuz veri dizinlerinden export ederek elde ettik. Uygulamalarımızda çoğu zaman verilerimizi bir internal veya external API’lere çağrıda bulunarak elde etmemiz gerekecek. Bunu native olan Fetch fonksiyonu ile de yapabiliriz fakat biz bu bölümümüzde web servis isteklerinde çoğu zaman kullanılan “axios” modülünü import ederek kullanacağız.Axios, promise tabanlı ve ayrıca bizlere async-await yapısını da kullanabilme olanağı sunan bir HTTP istemcisidir. İlk olarak “axios” modulünü proje dizinimize indirerek dahil edelim.1npm install axios --save Ardından kurulum tamamlandıktan sonra App.js dosyamıza “axios” modülünü import edelim.123import React, { Component } from 'react';import { StyleSheet, Text, View, Button } from 'react-native';import axios from 'axios';Şimdi inceleyeciğimiz uygulamamızda bizlere rastgele kişi verileri sağlayan “ { const data = res.data; }) 1) Şimdi uygulamamıza dönecek olarsak, App.js dosyamızda içerisi boş olan name ve surname değişkenlerinin yer aldığı bir state oluşturalım. 1234state={ name: \"\", surname: \"\", }; 2) Component her mount edildiği zaman ilgili web servis çağrısından bulunmuş olalım ve state’imiz güncellensin. İlgili axios çağrımızı yazalım.12345678910componentDidMount() { axios .get(\"https://randomuser.me/api\") .then(user => {this.setState( // istek sonucunda bizlere bir \"user\" objesi döner. { name:user.data.results[0].name.first, // \"user\" içerisinden data>results[0]>name>first ile name değişkenimizi aldık. surname: user.data.results[0].name.last // \"user\" içerisinden data>results[0]>name>first ile surname değişkenimizi aldık. } )}) } 3) State’imiz her güncellendiği zaman ilgili değişkenlerimizi Text bileşeni içerisinde render ederek gösterelim.","link":"/2020/02/15/React-Native-Axios-ile-Web-Servis-Cagrimi/"},{"title":"React Native: React Navigation 5 #1","text":"Mobil uygulamalarımızı geliştirirken bir süre sonra, birden fazla sayfa sunumuna ihtiyaç duyacağımızı göreceğiz. Buradaki en kritik detaylardan birisi de sayfalar arası geçişleri yönetmek olacaktır. Bu yazımızda bir uygulamadaki sayfa yapılarını oluşturmamızda ve yönetmemizde bizlere çok büyük kolaylık sağlayan React Navigation kütüphanesinin kurulumundan ve detaylarından bahsedeceğiz. KurulumÖncelikle komut satırı aracılığı ile proje dizinine giderek aşağıdaki yüklemeleri yapıyoruz.1npm install @react-navigation/native React Navigation bir çok yardımcı programlardan oluşur. Kurulumumuzu tamamlamak için aşağıdaki dependencies yüklemelerini de yapmamız gerekecek. 1npm install react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view Eğer React Native tarafında 0.60 ve daha yüksek sürümünü kullanıyorsanız link işlemleri otomatik olarak yapılıyor, aksi halde link komutlarını da çalıştırmanız gerekecektir.0.60 ve üzerinde bir sürüm kullanıyorsanız bu adımı geçebilirsiniz.1react-native link react-native-reanimated react-native-gesture-handler react-native-screens react-native-safe-area-context @react-native-community/masked-view Not Yüklemeler sonrası eğer bağlantı konusunda hata alıyorsanız, projenizi tekrardan build etmenizde fayda olacaktır. React Navigation ile uygulama geliştirirken tüm yapıları en son NavigationContainer içerisine sarmalamamız gerekiyor. Bunu genellikle App.js veya index.js gibi ana dosyalarımızda kullanmamız gerekecektir. Daha fazlası için: - React Navigation 5.x Docs","link":"/2020/02/18/React-Native-1-React-Navigation-5/"},{"title":"React Native: React Navigation - Stack Navigator #2","text":"Bir web sayfasında “a” elementi sayesinde herhangi bir URL’ye tıkladığımızda başka bir sayfaya yönlendirilip geçiş yapabiliriz. Tıkladığımız URL bilgisi tarayıcının geçmiş yığınına eklenir. Biz geri butonu ile yeniden o sayfaya ulaşmak istediğimizde tarayıcı bu yığın üzerinden URL’ye ulaşır ve bizi tekrar geldiğimiz sayfaya yönlendirir. React Native tarafında web tarayıcılarında olduğu gibi bir geçmiş yığını söz konusu değildir. React Navigation’ın devreye girdiği kısım ise burasıdır. En sık kullanacağımız navigatorlerden biri olan Stack Navigator sayesinde uygulamamızdaki ekranlar arasında geçiş yapabilecek ve geçmiş sayfa yönetimini sağlayabileceğiz. React Navigation tarafında her bir navigator kendi kütüphanesi içerisinde yer alır. Şimdiye kadar kurulumunu yaptığımız bağımlılıklar React Navigation’ın navigatorler için temel yapı taşları idi. Stack Navigator’ı kullanmaya başlamadan önce kurulumunu yapalım. 1npm install @react-navigation/stack createStackNavigator içerisinde aldığı parametreler ile bizlere geri dönüş tipi olarak bir React bileşeni döndüren bir fonksiyondur. Navigator içerisinde tanımlayacağımız Screen ögeleri sayesinde gerekli route tanımlamalarını sağlamış oluruz. Örnek bir Stack Navigator yapısı Burada Stack yapımızın iki farklı rotası vardır. Bunlar “Home” ve “Detail” sayfalarıdır. Screen bileşeni rotamızın adını belirleyeceğimiz bir “name” özelliği ile oluşturacağımız bileşeni tanımlayacağımız “component” özelliğine sahiptir. -initialRouteName özelliğine vereceğimiz ekran değeri ile Stack yapımızda açılacak olan ilk sayfamızı belirtiriz. Örneğimizde bu özelliğe “Home” değerini verdik, eğer “Detail” olarak verseydik uygulamamızı ilk çalıştırdığımızda Detail sayfası ile karşılaşacaktık. -screenOptions özelliği ile Stack yapımızdaki Screen’ler için varsayılan özellik atamaları yaparız. Ekranlar Arası GeçişStack içerisinde tanımladığımız başka bir route’a geçiş yapabilmek için this.props.navigation altındaki navigate(“RouteName”) özelliğini kullanırız. Şimdi HomeScreen’e bir buton ekleyelim ve butona tıkladığımızda DetailScreen’a yönlendirelim. -this.props.navigation.push(“RouteName”) ile bir route’a istediğimiz kadar geçiş isteği atabiliriz. Bu şekilde kaç defa geçiş işlemi yapıldıysa geri dönerken de aynı sayfa yapıları ile karşılaşılır. -this.props.navigation.goBack() ile geçiş yapmadan önce bulunduğumuz sayfaya geri dönme işlemi yapılır. -this.props.navigation.popToTop() ile geçişler arasındaki ilk sayfaya yönledirme işlemi yapılır. Sayfalar Arası Parametre GöndermeStack Navigator ile rotalarımızı oluşturduk ve bunlar arasında nasıl gezebildiğimizi gördük. Şimdi ise bir sayfadan diğer sayfaya geçiş yaparken nasıl parametre aktaracağımızı görelim.İlk olarak parametrelerimizi bir obje aracılığı ile “navigation.navigate() fonksiyonuna ikinci bir parametre olarak aktarırız.Örnek: navigation.navigate(‘RouteName’, { /* parametre değerleri… */ })Sonra ise Screen bileşenlerimizde bu değerleri route.params ile yakalayarak okuyabiliriz. Örneğimizde HomeScreen’de yer alan bir buton aracılığı ile DetailScreen’e name, surname, age değerlerini parametre olarak gönderdik ve sayfamızda gösterdik. Daha fazlası için: - React Navigation 5.x Docs","link":"/2020/02/18/React-Native-2-React-Navigation-Stack-Navigator/"},{"title":"React Native: React Navigation - Drawer Navigator #3","text":"Drawer Navigator; genellikle birden fazla, birbirleri ile ilişkisi olmayan hedefler arasında hızlıca ve kolayca geçişler yapmamızı sağlayan navigator çeşididir. Ekranımızda kalıcı olarak veya bir menü ikonu simgesiyle ulaşılıp kontrol edilebilir. Bu yazıda React Navigation altında gelen DrawerNavigator kütüphanesinin kurulumunu yapıp inceleyeceğiz. KurulumProje dizinimize gelerek komut satırı vasıtası ile ilk önce gerekli kütüphanemizi yükleyelim: 1npm install @react-navigation/drawer Kurulumumuzu yaptıktan sonra drawer yapısını görüp, daha iyi anlayabilmek açısınından basit bir örnek yapalım.Örneğimizde iki adet ayrı ayrı Screen döndüren fonksiyonlarımızı oluşturalım. Bunlardan bir tanesi Anasayfa diğeri ise Hakkımda olsun. import { createDrawerNavigator } from ‘@react-navigation/drawer’ ile sayfamıza import işlemini yapalım. Drawer Navigator tanımı: const Drawer = createDrawerNavigator() Mevcut durumda drawer menusunu açmak veya kapatmak istersek; – Açmak için: navigation.openDrawer();– Kapatmak için: navigation.closeDrawer(); Drawer menusunun açık veya kapalı olduğu bilgisini almak için; – import { useIsDrawerOpen } from ‘@react-navigation/drawer’– const isDrawerOpen = useIsDrawerOpen() Drawer.Navigator altındaki bazı özellikler: – Drawer menusunun sağ veya solda açılmasını istiyorsak: drawerPosition {“right” veya “left”}– Navigator içerisindeki ekranlara varsayılan ayarlar atamak için: screenOptions– Drawer menusunu açarken farklı şekilde görüntüleyebiliriz: drawerType {“front”, “back”, “slide”}– Drawer navigator için stil tanımlamaları yapmak için: drawerStyle {backgroundColor,width..} Daha fazlası için: - React Navigation 5.x Docs","link":"/2020/02/19/React-Native-3-React-Navigation-Drawer-Navigator/"},{"title":"React Native: React Navigation - Tab Navigator #4","text":"Modern mobil uygulamalar çoğu zaman karşımıza tek bir ekran modeli ile çıkar. Ekranları sekmelere bölmek bu model için en çok başvurulan yöntemlerden bir tanesidir. Bu yazımızda React Navigation ile “Tab Navigator” kurulumuna ve kullanımına bakacağız. Kurulum Not: @react-navigation/native ve diğer bağımlılıkların kurulu olduğundan emin olun, kurmadıysanız öncelikle bu sayfadaki adımları inceleyerek devam edin. Eğer kurduysanız bu adımı atlayabilirsiniz. Tab Navigator Kurulumu:npm install @react-navigation/bottom-tabs Kullanımı// import { createBottomTabNavigator } from ‘@react-navigation/bottom-tabs’ …// const Tab = createBottomTabNavigator() Örnek Kullanım:Anasayfa, Keşfet ve Ayarlar adında 3 ayrı sayfamız olsun ve bu sayfalar için Tab Navigator aracılığı ile altta sekmeler oluşturalım. Şimdi Tab.Navigator bileşenin altında kullanacağımız prop tanımları ile sekmelerimi özelleştirelim. initialRouteName:Navigator ilk yüklendiği an varsayılan olarak açılacak ilk yolu belirtiriz. screenOptions:Navigator içerisindeki tanımladığımız ekranların varsayılan ayarlarını tanımlarız. tabBarOptions:tabBar objeleri için gerekli ayarların yapıldığı özellik. İçerdiği bazı proplar:activeTintColor: Aktif olan sekmenin yazı rengi.activeBackgroundColor: Aktif olan sekmenin arkaplan rengi.inactiveBackgroundColor: Aktif olmayan sekme/sekmelerin arkaplan rengi.inactiveTintColor: Aktif olmayan sekme/sekmelerin yazı rengi.labelPosition: Yazının kullanılacak iconun neresinde duracağını belirtir. Varsayılan olara label iconun altındadır.style: tab bar için stil tanımlamalarını içerir. Icon EklemeSekmelerimize kendi oluşturduğumuz iconları dahil edebileceğimiz gibi çeşitli hazır icon kütüphanelerinden de yararlanabiliriz. Biz bu örneğimizde reac-native-vector-icons altında gelen “Ionicons” icon modülünden yararlanacağız. Ekran bileşenimizin desteklediği “option” propu içerisinde “tabBarIcon(focused: boolean, color: string, size: number)”‘a simgemizi içeren bileşenimizi tanımlıyıyoruz. Örnek Kullanım:","link":"/2020/02/21/4-React-Navigation-Tab-Navigator/"},{"title":"Android Programlama: Activity Sınıfı","text":"Activity sınıfından türettiğimiz her bir nesne, uygulamalarımızı geliştirirken tasarladığımız kullanıcı arayüzlerini yani sayfaları temsil etmektedir. Oluşturduğumuz her bir sayfanın kullanıcı ile gerçekleştirdiği etkileşimler Activity sınıfı sayesinde gerçekleştirilir. Oluşturacağımız her bir activity bir arayüzünden sorumludur ve mutlaka AndroidManifest.xml dosyasında tanımlanması gerekmektedir. Tanımlanmadığı taktirde activity ile karşılaşılan ilk anda uygulamanın yürütümü sonlandırılır. Activity Yaşam Döngüsü onCreate() Bir activity oluşturulup, çalışmaya başlamasının ardından tetiklenecek olan ilk metotdur. Eğer finish() metodu aracılığı ile veya başka bir nedenden dolayı silinmediği sürece yaşam döngüsü boyunca bir kere çalışır. Ardından sırasıyla onStart() ve onResume() metotları çalıştırılır. onStart(), onCreate()’den hemen sonra arayüz elemanları oluşturulduktan sonra çağırılır. onResume() ile de artık kullanıcı ile etkileşime geçilmiştir. Activity çalıştırılmadan önce çalışan son metotdur. Eğer uygulama içerisinde başka bir ekrana geçiş yapılıp o activity durdurulursa, geri dönüldüğünde activity onResume() ile tetiklenerek devam eder. Eğer activity kullanıcı tarafından arka plana atılırsa, sırasıyla onPause() ve onStop() metotları tetiklenir. Bu arada activity stack’de artık en önde değildir. Geri mevcut activity’e dönüldüğünde ise sırasıyla onStart() ve onResume() çalıştırılır. Activity kapatıldığı anda ise onPause() ve onStop() metotlarının ardından onDestroy() tetiklenerek activity yok edilir ve yaşam döngüsü biter. Activity yaşam döngüsünde tanımlanması zorunlu olan tek metod onCreate metodudur. Eğer bir activity stack’de arkaplana atılacaksa ve biz o an bulunan verilerin kaybolmasını istemiyorsak onSaveInstanceState(Bundle bundle) ve onRestoreInstanceState(Bundle bundle) metodlarını activity içerisinde tanımlamamız gerekir.onSaveInstanceState(): Activity arkapalana atıldığı zaman tetiklenen metoddur.onRestoreInstanceState(): Activity bazen farklı nedenlerden dolayı işletim sistemi tarafından sonlandırılabilir. Bu durumda activity tekrar odak haline geldiğinde onStart metodundan hemen sonra tetiklenen metoddur. Örnek: 1234567891011@Overrideprotected void onSaveInstanceState(Bundle kaydedilecekDeger) {super.onSaveInstanceState(kaydedilecekDeger);kaydedilecekDeger.putInt(\"Numara\", Integer.parseInt(txtNumara.getText().toString()));}@Overrideprotected void onRestoreInstanceState(Bundle kaydedilmisDeger) {super.onRestoreInstanceState(kaydedilmisDeger);int num = kaydedilmisDeger.getInt(\"Numara\");txtSayi.setText(Numara + \"\");}Not: Bundle sınıfı nesneleri ile; putByte(String key, byte value) byte, putDouble(String key, double value) double, putString(String key, String value) String, putFloat(String key, float value) float, putLong(String key, long value) long tipinde veriler de saklayabiliriz. Aynı şekilde okumak için de; getByte(String key) getDouble(String key) getString(String key) getFloat(String key) getLong(String key) Context SınıfıUygulamalardaki bileşenlerin oluşturulmasını, hem kendi aralarında hem de işletim sistemi ile bağlantı kurmasını sağlayan sınıftır. Dolayısıyla Activity’nin ata sınıfıdır. R SınıfıBazı zamanlar oluşturduğumuz sınıf içerisinde kaynak dosyalarından değer almak zorunda kalabiliyoruz. Örnek vermek gerekirse, res klasoru altında tanımladığımız bir renk kodu, uygulama adı, özel bir değişken örnek verilebilir. İşte bu değişkenlerin Java class’ları içerisinde kullanısını sağlayan R sınıfıdır. IDE tarafından otomatik olarak oluşturulur. Arayüz Geliştirme Kaynak Kod (XML) ile Arayüz Geliştirme Design Penceresi ile Arayüz Geliştirme Kaynak : Dr. Abdullah Talha KABAKUŞ (http://akademik.duzce.edu.tr/talhakabakus)","link":"/2020/02/29/Android-Programlama-Activity-ve-Layout/"},{"title":"Android Programlama: Layout Sınıfları","text":"Android uygulamalarında ekranlarda kullandığımız bileşenlerin yerleşim düzeni ve ekran tasarımları Layout sınıfları tarafından sağlanır. res klasoru altında tanımlanan layout dosyaları XML formatındadır ve içerisinde Android bileşenlerine özel etiketler sayesinde farklı özellikler belirtilir. Bütün layout sınıfları kendisi de View‘dan türeyen View Group sınıfıdan türemiştir ve layoutlara yükseklik ve genişlik değerleri atamaları zorunludur. Ölçü Birimleri ve Tanımlamaları: px: Ekranın fiziksel piksel değeridir. Cihazlar arasında farklılık göstereceği için tavsiye edilmez. dp: Cihaz ekranlarının fiziksel yoğunluğuna bağlı göreceli, soyut birimdir. Arayüz bileşenlerinin büyüklüklerini tanımlarken sıklıkla kullanılır. sp: dp ile aynı şekilde fakat font boyutlarının tanımlanması için tercih edilir. wrap_content: Kullanılan bileşenin içeriğine göre yüksekliğinin ve genişliğinin otomatik olarak düzenlenmesini sağlayan özellik. Layout ÇeşitleriLinearLayoutLinearLayout içinde bulunan bileşenlerin tek bir yönde diğer bir anlamda tek çizgide yerleştirip kullanmamızı sağlar. Bu hizalama horizontal (yatay) veya vertical (dikey) olabilir ve orientation özelliği sayesinde bunu belirtip kullanabiliriz.1android:orientation=\"vertical\"Default değeri horizontal‘dır. Bileşenlere dışarıdan boşluk değeri ataması layout_marginLeft: Sol taraftan, layout_marginRight: Sağ taraftan, layout_marginTop: Yukarıdan, layout_marginBottom: Aşağıdanözellikleri ile tanımlanır. Bütün hepsinden eşit boşluk bırakılmak isteniyorsa layout_margin özelliği kullanılır.12345678910111213141516171819202122232425 Hizalama İşlemleri (Gravity)Hizalama işlemleri bileşenlerin bulunduğu ata bileşene göre layout_gravity özelliği ile tanımlanır.(“left”, “right”, “center”,”top”, “bottom” “center_horizontal”, “center_vertical”)Bileşen içerisinde bir hizalanma işlemi yapmak için de sadece gravity kullanılmaktadır. 123456123456123456 Weight KavramıUygulamalarımızdaki bileşenlerin float değerler atanarak bulunduğu taşıyıcıya göre yükseklik/genişlik tanımlamalarının yapılmasını sağlar.12345678910111213141516171819 AbsoluteLayoutEkranın koordinat sistemi olarak değerlendirilip buna göre içerisinde yer alan bileşenlerin konumlandırıldığı layout çeşitidir. Ekranın en üst sol köşesi (0,0) olarak belirlenmiştir. AbsoluteLayout “deprecated” olarak tanımlanır, yani ilerideki sürümlerde gerekli desteği alamayacağı ve kesileceği anlamına gelir. Koordinat düzeninin kapsamı cihazlarda farklılık göstereceği için kullanımı bu yüzden tavsiye edilmez. RelativeLayoutUygulamadaki bileşenlerin diğer bileşenlere göre göreceli olarak yerleştime esasına göre uygulanır. Bir bileşenin konumu ve nerede olacağı diğer bileşenlere göre belirlenir. RelativeLayout aşağıdaki ön tanımlı özellikler ile tanımlanır. layout_alignParentLeft=”true”: Ata bileşene göre sola, layout_alignParentTop=”true”: Ata bileşene göre üste, layout_alignParentRight=”true”: Ata bileşene göre sağa, layout_alignParentBottom=”true”: Ata bileşene göre aşağıya, layout_centerVertical=”true”: Dikey eksende ortalama, layout_centerHorizontal=”true”: Yatay eksende ortalama, layout_below=”bilesen_id”: id ile belirtilen bileşenin altına, layout_toEndOf=”bilesen_id”: id ile belirtilen bileşenin yatayda sağına, layout_above=”bilesen_id”: id ile belirtilen bileşenin üstüne, layout_alignStart=”bilesen_id”: İlgiliid ile belirtilen bileşenin yatayda başlangıcına hizalama işlemleri yapılır.1234567891011121314151617181920212223242526272829303132333435363738394041 FrameLayoutUygulamalarda genellikle tek bileşen barındırıldığı zaman kullanılan layout çeşididir. Eğer birden fazla bileşen tanımlanırsa bileşenler üst üste konumlandırılacaktır. GridLayoutEkranın satır ve sütunlara bölünerek bileşenlerin yerleştirildiği layout çeşididir. android:rowCount: Satır sayısı android:columnCount: Sütun sayısı Hizalandırma soldan sağa ve yukarıdan aşağı şekilde yapılır. Bileşenlerin kaplayacağı satır sayısı layout_rowSpan, sütun sayısı ise layout_columnSpan ile belirlenir. ConstraintLayoutLayout çeşitleri arasında hem performansı hem de uyumluluk göze aldındığında tavsiye edilen ve en çok kullanılan layout çeşididir. Konumlandırmada kullanılan özellikler: layout_constraintTop_toTopOf layout_constraintTop_toBottomOf layout_constraintBottom_toTopOf layout_constraintBottom_toBottomOf layout_constraintLeft_toTopOf layout_constraintLeft_toBottomOf layout_constraintLeft_toLeftOf layout_constraintLeft_toRightOf layout_constraintRight_toTopOf layout_constraintRight_toBottomOf layout_constraintRight_toLeftOf layout_constraintRight_toRightOf layout_constraintBaseline_toBaselineOf Bileşenleri birbirlerine göre ya da ata bileşenlerine göre yerleştirmemizi sağlar. Örnek vermek gerekirse;2 adet ButonA ve ButonB adında butonlarımız olsun. ButonB, ButonA’nın sağında kalsın istiyorsak; ButonB’nin constraintLeft‘inin toRightOf‘una ButonA tanımlanması gerekir.12345678910111213141516171819202122232425 ButonB, ButonA’nın altında kalmasını istiyorsak; ButonB’nin constraintTop‘ının toBottomOf‘una ButonA tanımlanması gerekir.12345678910111213141516171819202122232425262728 Bir bileşeni yatayda ortalamak için;12app:layout_constraintLeft_toLeftOf=\"parent\"app:layout_constraintRight_toRightOf=\"parent\" Bir bileşeni dikeyde ortalamak için;app:layout_constraintTop_toTopOf=\"parent\" app:layout_constraintBottom_toBottomOf=\"parent\" ``` Bileşeni yatay ve dikeyde belli bir orana göre hizlandırmak istenildiği zaman bias özelliği kullanılır.0; yatayda en sol, dikeyde en üst1; yatayda sağ, dikeyde en alt değeri belirtir. layout_constraintHorizontal_bias ile yatayda,layout_constraintVertical_bias ile de dikeyde bias değeri ataması yapılır. Örnek vermek gerekirse, bir bileşene;app:layout_constraintHorizontal_bias=”0.8”app:layout_constraintVertical_bias=”0.3” atamaları yapıldığı zaman yatay hizada 0.8 oranında, dikey hizada ise 0.3 oranında hizalamış oluyoruz. Kaynak : Dr. Abdullah Talha KABAKUŞ (http://akademik.duzce.edu.tr/talhakabakus)","link":"/2020/02/29/Android-Programlama-Layout-Siniflari/"},{"title":"NodeJS - NodeJS'e Giriş/Kurulum","text":"NodeJS nedir?NodeJS Javascript kodlarımızı sunucu tarafında çalıştırabildiğimiz işlem bazlı (event-based), ölçeklendirilebilir (non-blocking) bir açık kaynak kodlu uygulama geliştirme çatısıdır. Peki nedir bu işlem bazlı veya ölçeklendirilebilirlik?Örnek senaryo üzerinden anlatacak olursak; bir işlem yapmak için herhangi kurum/işletmeye gittiğimi düşünelim ve kuyrukta beklediğimizi varsayalım. Kurum/işletme işlemleri yapmak için sizlere bir form veriyor ve önce bu formu doldurmanızı istiyor. Sırası gelen kişinin formu doldururken arkada bekleyen kişileri bekletmesi çok mantıklı değildir. İşlem bazlı çalışan sistemlerde her bir olay kendi işlevini görür ve diğer olayları ilgilendirmez. Bu durumda verdiğimiz örnekte sırası gelen her bir kişi formunu aldıktan sonra kuyruktan ayrılıp başka bir yerde doldurmaya başlarsa ve olay bu şekilde işlerse hiç kimse arkasındaki diğer kişileri bekletmiş olmayacak, formu dolduran kişi geri görevli kişiye formunu teslim ederek işlemini tamamlamış olacaktır. Diğer türlü yani Thread Based yapıda olmuş olsaydı sistem, kuyruktaki her bir kişi önündeki insanların sırasıyla formu doldurup teslim etmesini bekleyecekti ve sistemi blokladığı gibi arkasında bekleyen bir işi de bloklamış olacaktı. İşte ölçeklendirilebilir yani non-blocking dediğimiz kavram ise NodeJS’in event-based kavramı ile hareket ederek bloklama işlemlerini ortadan kaldırması olayıdır. Kurulum ve İlk KomutAşağıdaki linkten ilgili işletim sistemi ve sistem gereksinimlerine özel indirme dosyasını indiriniz.https://nodejs.org/en/download/ Şimdi komut satırı aracılığı ile NodeJS’in kurulu olduğu dizine gidelim ve “node” komutu ile ilk programımızı çalıştıralım.","link":"/2020/03/03/NodeJS-NodeJS-e-Giris-Kurulum/"},{"title":"NodeJS: Global Nesneler","text":"Javascript ile tarayıcı tarafında işlemler yaparken “window” nesnesi altındaki çeşitli fonksiyonları, değişken ve nesneleri kullanıyorduk. NodeJS tarafında window nesnesinin görevini “global” adı verilen nesne alabilir diyebiliriz. Şimdi global nesnesi altında ulaşabileceğimiz çeşitli fonksiyonlara, değişkenlere ve nesnelere göz atalım. Class: Buffer: Dosya okuma ve yazma gibi işlemlerde öncelikle ikili sayı sistemine gereksinim duyulur. NodeJS bu tür işlemlerde Buffer nesnesini kullanır.Kullanım:123const buffer = Buffer.from('Dogukan Sahin');console.log(buffer);// Console: Buffer 44 6f 67 75 6b 61 6e 20 53 61 68 69 6e __filename: O an üzerinde çalıştığımız dosyanın path adresini verir.Kullanım:1console.log(__filename)__dirname: Üzerinde çalışılan dosyanın path adresini verir.1console.log(__dirname)console: Ekrana yazdırma işlemi için kullanılan nesnedir. bir çok metoda sahiptir. (log(), error(), table(), info(), time(), timeLog())Kullanım:12let errorMessage = \"Error Message\";console.error(errorMessage);module: Kullanılan moduller hakkında bilgi almak veya direkt modul yazarken kullanılır.module.exports: Yazılan bir modulün kullanıma hazır hale getirip dışarı aktarmak için kullanılır.Kullanım:12345678module.exports = { name: \"Dogukan\", surname: \"Sahin\", yazdir: function () { console.log(this.name + \" \" + this.surname) } };exports: Bir değişkeni, fonksiyonu veya nesneyi dışarı aktarmak için kullanılır. module.exports ile aynı görevi yapar, bir nevi daha tekil nesneleri dışarı aktarmak için kullanılır.Kullanım:1234567exports.name = \"Dogukan\";exports.surname = \"Sahin\";exports.yazdir = function () { console.log(\"Dogukan Sahin\")};require: Harici veya kendi yazdığımız modulleri ilgili projeye dahil etmek için kullanılır.Kullanım:12const http = require(\"http\");const moduleA = require(\"./moduleA\");Function: setTimeout(): Parametre olarak verilen bir fonksiyon ile milisaniye tipinde zaman ile belirtilen işlevin o zaman dilimi geçtikten sonra çalıştırılmasını sağlar. 1000 ms 1 saniyeye denk gelmketedir.Kullanım:1234setTimeout(()=>{ console.log(\"Fonksiyon çalıştı!\")}, 3000);// 3 saniye sonra ilgili fonksiyon çalışarak çıktıyı ekrana verir.Function: clearTimeout(): setTimeout fonksiyonu ile zamanladığımız bir işlemi iptal etmek için kullanılır.Kullanım:12345const yazdir = setTimeout(()=>{ console.log(\"yazdir fonksiyonu çalıştı!\")}, 3000);clearTimeout(yazdir); Kaynak ve daha fazlası için; https://nodejs.org/api/globals.html#globals_console","link":"/2020/03/04/NodeJS-Global-Nesneler/"},{"title":"NodeJS: Events Module","text":"Events Module NodeJS’de bizlere değişik amaçta olaylar tanımlayıp, daha sonra bunları tetiklememizi sağlayarak olay yönetimine imkan modüldür. Events modülünden ürettiğimiz nesneler sayesinde kendimize özgü olaylarımızı düzenleyip istediğimiz yerde kullanabiliriz. İlk olarak event modülünü projemize dahil edelim.1const Event = require(\"events\"); Olaylarımızı tanımlamak ve tetiklemek için dahil ettiğimiz modül sınıfından bir nesne üretelim.1const emitter = new Event(); Oluşturduğumuz nesne ile on() metodu aracılığıyla bir olay üretelim. Birinci parametremiz olayımızın tanımı, ikinci parametre ise olay tetiklendiği an gerçekleşecek olay.1234emitter.on(\"girisYap\", ()=>{ console.log(\"Giriş YAPILDI!\")}); Şimdi ise bir olayı tetiklememizi sağlayan emit() metodu aracılığı ile olayımızı tetikleyelim ve gerçekleştirelim.12emitter.emit(\"girisYap\");// Console: Giriş YAPILDI! Olaylarımızı tetiklerken parametre göndererek de tetikleyebiliriz.12345678910const Event = require(\"events\");const emitter = new Event();emitter.on(\"girisYap\", (ad,soyad)=>{ console.log(ad + \" \" + soyad + \" \" + \"giriş YAPTI!\")});emitter.emit(\"girisYap\",\"Doğukan\",\"Şahin\");// Console: Doğukan Şahin giriş YAPTI!","link":"/2020/03/04/NodeJS-Events-Module/"},{"title":"NodeJS: File System Module","text":"File System Module NodeJS uygulamalarımızda bizlere dosyadan veri okuma, yazma ve birçok dosya işlemlerini yapmamıza olanak sağlayan bir çekirdek modüldür. Projemize modülümüzü fs anahtar kelimesi ile dahil edelim.1const fs = require(\"fs\") Dosya Okuma: fs.readFile(path, options callback); 12345678fs.readFile(\"text.txt\", \"utf-8\", (error,data)=>{if (error) { console.log(error)}else { console.log(data)}}); Dosyaya Veri Yazma: fs.writeFile(file, data, options, callback) 12345678fs.writeFile(\"text.txt\", \"Doğukan ŞAHİN\",\"utf-8\", (error,data)=>{if (error) { console.log(error)}else { console.log(\"Veri yazma işlemi tamamlandı!\")}}); Dosya Silme fs.unlink(path, callback)123fs.unlink(\"text.txt\", ()=>{ console.log(\"Dosya basarıyla silindi!\")}); Dizindeki klasörleri listeleme fs.readdir(path, callback);12345678fs.readdir(\"./\", (error,data)=>{if (error) { console.log(error)}else { console.log(data)}}); Yeni bir klasör oluşturma fs.mkdir(path, mode, callback); 123fs.mkdir(\"yeniKlasor\", ()=>{ console.log(\"Klasor basarıyla olusturuldu!\")}); Mevcut klasörü silme fs.rmdir(path, callback); 123 fs.rmdir(\"yeniKlasor\", ()=>{console.log(\"Klasor basarıyla silindi!\") }); Daha fazlası için: https://nodejs.org/api/fs.html","link":"/2020/03/04/NodeJS-File-System-Module/"},{"title":"NodeJS: Module Kavramı","text":"NodeJS projelerinde kullandığımız modüller, bir veya daha fazla javascript dosyalarına yazdığımız karmaşık veya basit kod yapılarıdır. Modüller içerisinde tanımlı olan her değişken kendi kapsamı içerisinde değerlendirilir. Yani bir modül içerisinde yer alan tanımlı değişken genel kapsama dahil bir değişkeni etkilemez. Modül kavramı sayesinde yazılan bütün işlevler ilgili projeye dahil edilerek istenildiği kadar kullanılabilir. NodeJS yapılarında modüller 3 farklı alanda kategorilendirilebilir; Core veya Node Modules: Herhangi bir indirme işlemi yapmadan, NodeJS kaynak dosyaları ile beraber gelen çekirdek yazılımlardır. Sadece projeye dahil edilerek kullanılır. File System Module Path Module OS Module Http Module Url Module Custom Modules: Javascript dosyalarına kendi yazdığımız modüllerdir. 3rd Party Modules: Paket yöneticisi vasıtası indirip kullanabileceğimiz, dışarıdan başkaları tarafından oluşturulmuş modüllerdir. ExpressJs Mongoose Electron Custom (Yerel) Module Oluşturma ve KullanımıModül tanımlama ve yazdığımız bu modülleri başka bir dosyada kullanmamız için module.export veya export anahtar kelimeleri kullanılır.Şimdi firstModule.js adında bir .js dosyası oluşturalım ve ilk modülümüzü yazalım.Oluşturduğumuz modülde ad,soyad ve yaş bilgilerini tutan değişkenler ve bu değerleri yazdıran “bilgiYazdir” adında fonksiyonumuz olsun.123456789module.exports= { ad: \"Doğukan\", soyad: \"Şahin\", age: 23, bilgiYazdir: function () { console.log(this.ad + \" \" + this.soyad + \" \" + this.age) } }Yazdığımız modülü module.export ile dışarıda kullanılabilir hale getirdik. Şimdi başka bir dosyamızda bu modülü dahil ederek nesnemize ulaşmaya çalışalım. Moduller “reguire(./)” anahtar kelimesi ile dahil edilir. 12345678910111213const myModule = require(\"./firstModule\");console.log(myModule.ad);console.log(myModule.soyad);console.log(myModule.age);myModule.bilgiYazdir();// Console: // Doğukan// Şahin// 23// Doğukan Şahin 23","link":"/2020/03/04/NodeJS-Module-Kavrami/"},{"title":"NodeJS: URL Module","text":"NodeJS ile gelen URL Module bizlere uygulamamıza gelen web adreslerinin içeriklerine ulaşarak bu bilgileri daha anlamlı bir şekilde kullanmamıza olanak sağlar. İlk olarak url modulünü projemize dahil edelim.1const url = require(\"url\"); Uygulamıza bir adres geldiğini düşünelim ve işlem yapacağımız bu adresi bir şimdilik bir değişkene atayalım.1const adres = \"https://dogukansahin.net/a/b/c/d?value=1245&value2=abcd\"; url modülü üzerinden ulaşabildiğimiz parse() metodu bizlere adresimiz hakkında birçok bilgi içeren bir obje döndürür.123456789101112131415161718192021222324 const adresBilgileri = url.parse(adres); console.log(adresBilgileri); /* Console: Url { protocol: 'https:', slashes: true, auth: null, host: 'dogukansahin.net', port: null, hostname: 'dogukansahin.net', hash: null, search: '?value=1245&value2=abcd', query: 'value=1245&value2=abcd', pathname: '/a/b/c/d', path: '/a/b/c/d?value=1245&value2=abcd', href: 'https://dogukansahin.net/a/b/c/d?value=1245&value2=abcd' } */``` * Bu objeyi atadığımız değişken üzerinden adresimiz hakkında istenilen özelliğe ulaşabiliriz.```Javascript // Host adı const hostName = adresBilgileri.host; console.log(hostName); // Console: dogukansahin.net Eğer query bilgilerinin ayrı bir obje olarak tutulmasını istiyorsak parse() metoduna ikinci parametre olarak true değeri atanır.const adresBilgileri = url.parse(adres,true); console.log(adresBilgileri); /* Console: Url { protocol: 'https:', slashes: true, auth: null, host: 'dogukansahin.net', port: null, hostname: 'dogukansahin.net', hash: null, search: '?value=1245&value2=abcd', query: [Object: null prototype] { value: '1245', value2: 'abcd' }, pathname: '/a/b/c/d', path: '/a/b/c/d?value=1245&value2=abcd', href: 'https://dogukansahin.net/a/b/c/d?value=1245&value2=abcd' } */","link":"/2020/03/04/NodeJS-URL-Module/"},{"title":"NodeJS: HTTP Module","text":"Uygulamalarımızda web sitesi veya bir servis aracılığı ile gelen istekleri karşılamak veya yanıtlamak isteyeceğimiz zaman bir web sunucuna ihtiyaç duyarız. NodeJS ile içerisinde çekirdek modül olarak gelen http modulü sayesinde bir istemci ile sunucu arasındaki bağlantı alışverişi sağlanır. İlk olarak http modülünü projeye dahil edelim.1const http = require(\"http\") http üzerinden createServer() metodu bir server nesnesi üretmemizi sağlar. Biz de burada “server” adını verdiğimiz bir nesne oluşturalım.1const server = http.createServer() Oluşturduğumuz server’ın hangi port üzerinde dinleneceğini listen() methodu ile tanımlıyoruz.1server.listen(3000); createServer() metodu içerisine gelen isteklerimi ve yanıtlarımızı yönetmek için request ve response objelerini içeren bir callback tanımlanır. Örnek olarak biz burda gelen isteğin method tipini öğrenmeye çalışalım.1234567const http = require(\"http\");const server = http.createServer((req,res)=>{console.log(req.method);});server.listen(3000); Şimdi ise gelen bir isteğe URL kontrolü yaparak bir response döndürelim. Örneğimizde eğer gelen isteğin URL’si “/home” ise “Anasayfa”, “/about” ise “Hakkımda” yazan bir mesaj değeri gönderelim ve yazdıralım. const http = require(\"http\"); const server = http.createServer((req,res)=>{ if (req.url === \"/home\") { res.write(\"Anasayfa\"); res.end() } if (req.url === \"/About\") { res.write(\"Hakkımda\"); res.end() } }); server.listen(3000); Not: Bir response değeri gönderiyorsak eğer sonunda end() ile sonladırmamız gerekiyor.","link":"/2020/03/05/NodeJS-HTTP-Module/"},{"title":"Java EE: Servlet Kavramı","text":"Servlet HTTP protokolünü kullanarak istemciler ile sunucular arasında iletişim kurulamasını sağlayan Java nesneleridir. İstemciden gelen request mesajlarını okuyup, geri istemciye gönderilecek olan response mesajlarını oluşturur. javax.servlet-api kütüphanesi altından HttpServlet sınıfından türetilerek oluşturulur. HTTP GET ve POST isteklerini karşılamak için override edilebilir doGet, doPost gibi metodları vardır. Servlet Yaşam Döngüsü Fotoğraf Kaynağı:(https://www.geeksforgeeks.org/life-cycle-of-a-servlet/) init() - Yükleme ve BaşlatmaServlet’in yüklenip, başlatılmasını sağlayan metoddur. Servlet Container tarafından tetiklenir. Servlet Container; servlet’lerin yüklenilmesi ile beraber başlatılması ve sonlandırılmasından sorumlu web sunucusudur. init(ServletConfig) metodu tetiklenirken web.xml dosyasında tanımlanan başlatma parametrelerini tutan ServletConfig nesnesi parametre olarak verilir. service() - Servis EtmeServlet’lere gelen her isteğe karşılık Servlet Container ilgili servlet’in service() metodunu tetikler. Gelen istek tipine bağlı olarak HTTP protokülüne karşılık gelen metodu tetikler. Bunlar; doGet() GET için, doPost() POST için gibi.. service() metodu iki adet parametre alır; HttpServletRequest HttpServletResponse destroy() - SonlandırmaServlet container’ın bir servlet’i sonlandıracağı zaman tetiklediği metoddur. destroy() metodu tetiklenmeden önce service() metoduna bağlı işlerin sonlandırılması beklenir. Kaynak : Dr. Abdullah Talha KABAKUŞ (http://akademik.duzce.edu.tr/talhakabakus)","link":"/2020/03/09/Java-EE-Servlet-Kavrami/"},{"title":"Android Programlama: Resource Kullanımı","text":"Uygulamalarımızı geliştirirken projemiz içerisinde res klasörü altında kaynak koddan bağımsız bazı veriler tutarız. Bu veriler bir arayüz dosyası olabileceği gibi; resim,video,metin diziler ya da bir style dosyası da olabilir. Kaynaklara ErişimXML Dosyalarında Kaynak KullanımıAşağıda tanımlandığı dosya ya da klasörlere göre kaynak id önekleri listelenmiştir. res/drawable/ : @drawable res/menu/ : @menu res/values/arrays.xml : @array res/values/dimens.xml : @dimen res/values/strings.xml : @string res/values/styles.xml : @style res/values/colors.xml : @color res/values/bools.xml : @bool res/values/integers.xml : @integer Örnek: res/values/strings.xml dosyasındaki buttonText adındaki string sabite ulaşalım.1 android:text=”@string/buttonText” … /> Java Sınıflarında Kaynak KullanımıJava sınıflarından kaynak dosyalarındaki sabitlere erişebilmek için this.getResources() nesnesi kullanılır. Bu nesne ile beraber döndürülecek verinin tipine bağlı olarak ilgili metodlar tetiklenir. getString(int id), getInt(int id), getDimension(int id)… gibi. Aşağıda yine tanımlandığı dosya ya da klasörlere göre kaynak id önekleri listelenmiştir. res/drawable/ : R.drawable res/menu/ : R.menu res/values/arrays.xml : R.array res/values/dimens.xml : R.dimen res/values/strings.xml : R.string, R.plurals res/values/styles.xml : R.style res/values/colors.xml : R.color res/values/bools.xml : R.bool res/values/integers.xml : R.integer res/layout/ : R.layout Örnek 1String buttonText = this.getResources().getString(R.string.buttonText);","link":"/2020/03/10/Android-Programlama-Resource-Kullanimi/"},{"title":"Android Programlama: Event Kavramı","text":"Event’lar uygulamalarda kullanıcıların arayüz bileşenleri ile oluşturduğu etkileşim sonucu oluşan olaylardır. Bir butona tıklama veya ekranın herhangi bir bileşenine dokunma event’lara örnek olarak verilebilir. Bu tür olayların fırlatıldığı anda programlarımızda dinleyici nesneler yardımıyla yakalayarak isteklerimize uygun işlemleri gerçekleştirebiliriz. Olayı daha iyi anlamak adına bir örnek yapalım. Bir adet Button ve TextView bileşenimiz olsun ve butona tıkladığımız an onClick() metodunu tetikleyerek bir olay fırlatalım. Ardından listener ile fırlattığımız olayı yakalayarak TextView’ın içerisindeki değeri her butona tıklanıldığı an 1 arttıralım.Gerekli arayüz seçimi ve XML stil tanımlamaları istenildiği gibi kurgulanabilir. Biz burada bir event üretip daha sonra onu yakalayarak gerekli işlemleri yapacağız. 123456789101112131415161718192021 public class MainActivity extends AppCompatActivity { private Button btnArttir; private TextView sayi; private int sayac = 0; @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); btnArttir = findViewById(R.id.button); sayi = findViewById(R.id.textView); btnArttir.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View view) { sayac++; sayi.setText(\"Tıklanma Sayısı: \" + sayac); } }); }} Fırlattığımız tıklanma olayını OnClickListener interface’inin onClick() metodunu override ederek yakalamış olduk.","link":"/2020/03/10/Android-Programlama-Event-Kavrami/"},{"title":"Hello World","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","link":"/2020/03/12/hello-world/"},{"title":"deneme","text":"denemeljgvjlfgkdgs slfjsnfjlnsklf sefksmfkls","link":"/2020/03/12/deneme/"}],"tags":[{"name":"dizi","slug":"dizi","link":"/tags/dizi/"},{"name":"programlama","slug":"programlama","link":"/tags/programlama/"},{"name":"c++","slug":"c","link":"/tags/c/"},{"name":"cpp","slug":"cpp","link":"/tags/cpp/"},{"name":"c","slug":"c","link":"/tags/c/"},{"name":"array","slug":"array","link":"/tags/array/"},{"name":"std::array","slug":"std-array","link":"/tags/std-array/"}],"categories":[{"name":"nodejs","slug":"nodejs","link":"/categories/nodejs/"},{"name":"javascript","slug":"javascript","link":"/categories/javascript/"},{"name":"reactnative","slug":"reactnative","link":"/categories/reactnative/"},{"name":"android","slug":"android","link":"/categories/android/"},{"name":"javaee","slug":"javaee","link":"/categories/javaee/"}]}